<!doctype html><html lang=ja><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>PostgreSQLでもストリーミングレプリケーションを試してみたい - レンコン畑でつかまえて</title><meta content=Postgres標準機能であるストリーミングレプリケーションを用いて、複数のクラスタ間でデータを同期出来る事を確認します name=description><link href=/pagefind/pagefind-ui.css rel=stylesheet><link href=/styles.css rel=stylesheet><link href=/feed.xml rel=alternate title=レンコン畑でつかまえて type=application/atom+xml><link href=/feed.json rel=alternate title=レンコン畑でつかまえて type=application/json><script src=/pagefind/pagefind-ui.js></script><script>window.addEventListener('DOMContentLoaded',()=>{new PagefindUI({"element":"#search","showImages":false,"excerptLength":0,"showEmptyFilters":true,"showSubResults":false,"resetStyles":false,"bundlePath":"/pagefind/","baseUrl":"/"});});</script><body><nav class=navbar><a class=navbar-home href=/> <strong>レンコン畑でつかまえて</strong> </a><ul class=navbar-links><li><a href=/> Home </a><li><a href=/posts/> Archive </a><li><a href=https://about.jyuch.dev/> About Me </a></ul><div class=navbar-search><div id=search></div></div></nav><main class=body-post><article class=post data-pagefind-body><div class=post-header><h1 class=post-title>PostgreSQLでもストリーミングレプリケーションを試してみたい</h1><nav class=post-tags><a class=tag href=/tags/postgres/>postgres</a></nav><time datetime="2021-11-08 00:00:00" class=post-date> November 8th, 2021 </time></div><div class=post-body><h2>はじめに</h2><p>この記事では、Postgres標準機能であるストリーミングレプリケーションを用いて、複数のクラスタ間でデータを同期出来る事を確認します。<p>また、プライマリが障害を起こした際にスタンバイで業務を継続出来る事も確認します。<h2>諸元</h2><p>ここでは、以下の諸元を使用してデータベースを構築します。<table><thead><tr><th style=text-align:left>ロール和名<th style=text-align:left>ロール名<tbody><tr><td style=text-align:left>レプリケーションユーザ<td style=text-align:left>repl_user<tr><td style=text-align:left>アプリケーションDB<td style=text-align:left>test_app<tr><td style=text-align:left>アプリケーションDBユーザ<td style=text-align:left>test_app</table><h2>プライマリデータベースクラスタの初期化</h2><p>まず、プライマリのデータベースクラスタを初期化し起動します。<pre><code class="language-sh hljs language-bash">initdb --no-locale --encoding=UTF-8 -D /home/jyuch/pgdata/11/primary
pg_ctl -D /home/jyuch/pgdata/11/primary start
</code></pre><p>プライマリクラスタにレプリケーションユーザを作成します。 また、あわせてテストユーザとデータベースを作成します。<pre><code class="language-sh hljs language-bash">psql -p 5432 postgres
</code></pre><pre><code class="language-sh hljs language-bash">postgres=# CREATE USER repl_user LOGIN REPLICATION PASSWORD <span class=hljs-string>'repl_user'</span>;
CREATE ROLE
postgres=# CREATE USER test_app LOGIN PASSWORD <span class=hljs-string>'test_app'</span>;
CREATE ROLE
postgres=# CREATE DATABASE test_app OWNER test_app;
</code></pre><p>異なるホスト間でレプリケーションを行う場合はレプリケーション先からレプリケーションユーザが接続出来るよう<code>pg_hba.conf</code>に設定を追加しますが、ローカルホスト間のレプリケーションは最初から許可されているためここでは設定を飛ばします。<p>テストデータベースに初期データを投入します。<pre><code class="language-sh hljs language-bash">$ psql -p 5432 -U test_app test_app

psql (11.12)
Type <span class=hljs-string>"help"</span> <span class=hljs-keyword>for</span> <span class=hljs-built_in>help</span>.

test_app=> CREATE TABLE foo (i int, v varchar(100));
CREATE TABLE
test_app=> INSERT INTO foo VALUES (1, <span class=hljs-string>'hoge'</span>), (2, <span class=hljs-string>'fuga'</span>);
INSERT 0 2
test_app=> <span class=hljs-keyword>select</span> * from foo;
 i |  v   
---+------
 1 | hoge
 2 | fuga
(2 rows)
</code></pre><p>プライマリの<code>postgresql.conf</code>を以下のように設定します。が、デフォルトで設定されているので大丈夫でしょう。<pre><code class="language-sh hljs language-bash">wal_level = replica
<span class=hljs-comment># 接続が急に切れたらコネクションがタイムアウトするまで残るので、必要数よりも少し大きめにする</span>
max_wal_senders = 10
max_replication_slots = 10
archive_mode = off
hot_standby = on
</code></pre><p>設定が完了したら、一度プライマリを再起動します。<pre><code class="language-sh hljs language-bash">pg_ctl -D /home/jyuch/pgdata/11/primary restart
</code></pre><h2>スタンバイクラスタのベースコピー</h2><p>スタンバイクラスタ用に<code>pg_basebackup</code>を使用してベースファイルのコピーを行います。<p>ここでは、レプリケーションスロットを新規で作成し、そのレプリケーションスロットを使用してベースバックアップを取得します。<p>レプリケーションスロットとは、プライマリ側で管理するスタンバイ側にどこまでのコミットが反映されたか管理するための機構です。 スタンバイ側が停止している間にプライマリ側に変更が行われた場合、スタンバイに未反映のWALは削除されず、スタンバイが復帰してレプリケーションが完了したらWALを消してくれるように制御してくれます。<p>そのため、逆にいつまでもスタンバイが復帰しない場合だとプライマリ側のWALが溢れるので、復帰しないの分かっている場合はレプリケーションスロットを消しておいた方が良いでしょう。<pre><code class="language-sh hljs language-bash">pg_basebackup -h localhost -D /home/jyuch/pgdata/11/standby -X stream --progress -U repl_user -R --create-slot --slot=localhost_standby
</code></pre><p>本来であればこの後スタンバイ側の<code>recovery.conf</code>を編集する必要があるのですが、なんか色々忖度して良い感じの設定を生成してくれているので、確認して良い感じだったらそのまま使います。<p>また、別サーバにスタンバイを立てているなら問題ありませんが、今回は同じサーバにスタンバイを立てている都合上スタンバイ側の待ち受けポートを<code>5433</code>に変更します。<pre><code class="language-sh hljs language-bash">port = 5433
</code></pre><p>待ち受けポートを変更したら、スタンバイ側を起動します。<pre><code class="language-sh hljs language-bash">pg_ctl -D /home/jyuch/pgdata/11/standby start
</code></pre><p>スタンバイとして起動すると、以下のメッセージが出力されます。<pre><code class="language-sh hljs language-bash">2021-08-10 15:59:45.519 JST [15881] LOG:  database system is ready to accept <span class=hljs-built_in>read</span> only connections
</code></pre><h2>プライマリとスタンバイの同期</h2><p>プライマリにデータを追加すると、スタンバイ側にも正常に伝搬していることが分かります。<pre><code class="language-sh hljs language-bash">$ psql -p 5432 -U test_app -c <span class=hljs-string>"INSERT INTO foo VALUES (3, 'puipui')"</span> test_app
INSERT 0 1
</code></pre><pre><code class="language-sh hljs language-bash">$ psql -p 5433 -U test_app -c <span class=hljs-string>"SELECT * FROM foo"</span> test_app
 i |   v    
---+--------
 1 | hoge
 2 | fuga
 3 | puipui
(3 rows)
</code></pre><p>また、プライマリ側でレプリケーション状態を確認すると、<code>state</code>が<code>streaming</code>（レプリケーション中）になっていることが確認出来ます。<pre><code class="language-sh hljs language-bash">$ psql -x -p 5432 -c <span class=hljs-string>"SELECT * FROM pg_stat_replication"</span> postgres
-[ RECORD 1 ]----+------------------------------
pid              | 15887
usesysid         | 16384
usename          | repl_user
application_name | walreceiver
client_addr      | 127.0.0.1
client_hostname  | 
client_port      | 41818
backend_start    | 2021-08-10 15:59:45.529388+09
backend_xmin     | 
state            | streaming
sent_lsn         | 0/3000320
write_lsn        | 0/3000320
flush_lsn        | 0/3000320
replay_lsn       | 0/3000320
write_lag        | 
flush_lag        | 
replay_lag       | 
sync_priority    | 0
sync_state       | async
</code></pre><p>レプリケーションに遅延が発生している場合は、以下のように表示されます。（異なるクラスタでの結果なので、色々表示が異なります。）<pre><code class="language-sh hljs language-bash">-[ RECORD 1 ]----+------------------------------
pid              | 51409
usesysid         | 10
usename          | jyuch
application_name | server1
client_addr      | 127.0.0.1
client_hostname  | 
client_port      | 50836
backend_start    | 2021-08-11 13:30:08.561606+09
backend_xmin     | 
state            | streaming
sent_lsn         | 0/3D4F078
write_lsn        | 0/3D4F078
flush_lsn        | 0/3D4F078
replay_lsn       | 0/3D4F078
write_lag        | 00:00:00.000164 ← これ
flush_lag        | 00:00:00.011684 ← これ
replay_lag       | 00:00:00.011922 ← これ
sync_priority    | 0
sync_state       | async
</code></pre><p>また、スタンバイ側でマスタのどこまでを反映したかを表示すると、以下のような感じになります。<pre><code class="language-sh hljs language-bash">$ psql -p 5433 -c <span class=hljs-string>"SELECT pg_last_xact_replay_timestamp()"</span> postgres
 pg_last_xact_replay_timestamp 
-------------------------------
 2021-08-10 16:04:35.821323+09
(1 row)
</code></pre><p>スタンバイ側はリードオンリーで起動しているため、データへの変更は出来ません。<pre><code class="language-sh hljs language-bash">$ psql -p 5433 -U test_app -c <span class=hljs-string>"INSERT INTO foo VALUES (4, 'standby')"</span> test_app
2021-08-10 16:37:29.526 JST [16558] ERROR:  cannot execute INSERT <span class=hljs-keyword>in</span> a read-only transaction
2021-08-10 16:37:29.526 JST [16558] STATEMENT:  INSERT INTO foo VALUES (4, <span class=hljs-string>'standby'</span>)
ERROR:  cannot execute INSERT <span class=hljs-keyword>in</span> a read-only transaction
</code></pre><h2>フェールオーバー</h2><p>フェールオーバーをテストするため、まずプライマリ側を停止させます。 <code>-m immediate</code>を指定する事で疑似的にクラッシュを再現します。<pre><code class="language-sh hljs language-bash">$ pg_ctl stop -m immediate -D /home/jyuch/pgdata/11/primary
</code></pre><p>※プライマリを停止させた瞬間から、スタンバイ側のログにプライマリに接続できねーよとログが出続けます。<p>スタンバイ側は引き続き参照は出来ますが、更新は出来ません。<pre><code class="language-sh hljs language-bash">$ psql -p 5433 -U test_app -c <span class=hljs-string>"SELECT * FROM foo"</span> test_app
 i |   v    
---+--------
 1 | hoge
 2 | fuga
 3 | puipui
(3 rows)

$ psql -p 5433 -U test_app -c <span class=hljs-string>"INSERT INTO foo VALUES (4, 'standby')"</span> test_app
ERROR:  cannot execute INSERT <span class=hljs-keyword>in</span> a read-only transaction
</code></pre><p>スタンバイをプライマリに昇格させるには、以下のコマンドを投入します。<pre><code class="language-sh hljs language-bash">$ pg_ctl -D /home/jyuch/pgdata/11/standby promote
waiting <span class=hljs-keyword>for</span> server to promote.... <span class=hljs-keyword>done</span>
server promoted
</code></pre><p>この状態であれば、新プライマリ（旧スタンバイ）から変更が出来るようになります。<pre><code class="language-sh hljs language-bash">$ psql -p 5433 -U test_app -c <span class=hljs-string>"INSERT INTO foo VALUES (4, 'standby')"</span> test_app
INSERT 0 1

$ psql -p 5433 -U test_app -c <span class=hljs-string>"SELECT * FROM foo"</span> test_app
 i |    v    
---+---------
 1 | hoge
 2 | fuga
 3 | puipui
 4 | standby
(4 rows)
</code></pre><h2>旧プライマリの復帰</h2><p>この状態から旧プライマリをスタンバイとして復帰させることも出来るっぽいですが、新プライマリにレプリケートされていないWALがある状態だと復帰出来ないらしいので、おとなしくクラスタを作り直してスタンバイとして追加した方が良さげです。<p>まぁこの辺は正直なんともかんともなので、本番環境でやる時は詳しい人に聞いた方が良いかもしれません。<pre><code class="language-sh hljs language-bash">pg_basebackup -h localhost -p 5433 -D /home/jyuch/pgdata/11/new-standby -X stream --progress -U repl_user -R --create-slot --slot=localhost_new_standby
</code></pre><pre><code class="language-sh hljs language-bash">port = 5434
</code></pre><pre><code class="language-sh hljs language-bash">pg_ctl -D /home/jyuch/pgdata/11/new-standby start
</code></pre><pre><code class="language-sh hljs language-bash">$ psql -p 5434 -U test_app -c <span class=hljs-string>"SELECT * FROM foo"</span> test_app
 i |    v    
---+---------
 1 | hoge
 2 | fuga
 3 | puipui
 4 | standby
(4 rows)
</code></pre><h2>スタンバイ停止時のレプリケート</h2><p>スタンバイ側を停止させてもデータロストは発生せず、プライマリ側の変更はスタンバイが復帰したタイミングでレプリケートされることが確認出来ます。<pre><code class="language-sh hljs language-bash">pg_ctl -D /home/jyuch/pgdata/11/new-standby stop
</code></pre><pre><code class="language-sh hljs language-bash">$ psql -p 5433 -U test_app -c <span class=hljs-string>"INSERT INTO foo VALUES (5, 'standby is offline')"</span> test_app
INSERT 0 1
</code></pre><pre><code class="language-sh hljs language-bash">$ pg_ctl -D /home/jyuch/pgdata/11/new-standby start
$ psql -p 5434 -U test_app -c <span class=hljs-string>"SELECT * FROM foo"</span> test_app
 i |         v          
---+--------------------
 1 | hoge
 2 | fuga
 3 | puipui
 4 | standby
 5 | standby is offline
(5 rows)
</code></pre></div></article><hr><nav class=post-navigation><ul><li>← Previous: <a href=/posts/2021/pg-config-on-windows/ rel=prev>WindowsでもPostgreSQLのチューニングをしたい</a><li><strong>Next: <a href=/posts/2021/pg-re-create-cluster-on-windows/ rel=next>WindowsでもPostgreSQLのデータディレクトリを移動したい</a> →</strong></ul></nav></main><footer><div><a href=/feed.xml> <svg viewbox="0 0 16 16" height=16 width=16 xmlns=http://www.w3.org/2000/svg><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"></path><path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"></path></svg> </a></div></footer>
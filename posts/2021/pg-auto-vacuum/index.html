<!doctype html><html lang=ja><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>PostgreSQLの自動バキューム・自動解析の発動条件を確認したい - レンコン畑でつかまえて</title><meta content=PostgreSQLの自動バキューム・自動解析の発動条件を解説しています name=description><link href=/pagefind/pagefind-ui.css rel=stylesheet><link href=/styles.css rel=stylesheet><link href=/feed.xml rel=alternate title=レンコン畑でつかまえて type=application/atom+xml><link href=/feed.json rel=alternate title=レンコン畑でつかまえて type=application/json><script src=/pagefind/pagefind-ui.js></script><script>window.addEventListener('DOMContentLoaded',()=>{new PagefindUI({"element":"#search","showImages":false,"excerptLength":0,"showEmptyFilters":true,"showSubResults":false,"resetStyles":false,"bundlePath":"/pagefind/","baseUrl":"/"});});</script><body><nav class=navbar><a class=navbar-home href=/> <strong>レンコン畑でつかまえて</strong> </a><ul class=navbar-links><li><a href=/> Home </a><li><a href=/posts/> Archive </a><li><a href=https://about.jyuch.dev/> About Me </a></ul><div class=navbar-search><div id=search></div></div></nav><main class=body-post><article class=post data-pagefind-body><div class=post-header><h1 class=post-title>PostgreSQLの自動バキューム・自動解析の発動条件を確認したい</h1><nav class=post-tags><a class=tag href=/tags/postgres/>postgres</a></nav><time datetime="2021-11-01 00:00:00" class=post-date> November 1st, 2021 </time></div><div class=post-body><h2>はじめに</h2><p>PostgreSQLは追記型アーキテクチャを採用しており、削除だけではなく更新でも参照されないタプルが発生します。<p>高い頻度で書き込みを行うデータベースでなければ自動バキューム（Auto Vacuum）でクリーンアップされるので特段気にすることはないと思いますが、どのタイミングで動くか分からない仕組みに依存するのも少し気が引けます。<p>というわけで、自動バキュームと自動解析の発動条件について確認してみたのでそれについてです。<h2>自動バキューム</h2><p>Postgresの自動バキュームはレコードの<code>update</code>、<code>delete</code>の合算した回数がしきい値を超えた場合にスケジュールされます。<p>閾値は<code>postgres.conf</code>のパラメータもしくはテーブルごとの設定値によって以下の計算式に従って計算されます。<pre><code>pg_stat.reltuples * autovacuum_vacuum_scale_factor + autovacuum_vacuum_threshold
</code></pre><h2>自動解析</h2><p>PostgreSQLの自動解析は<code>insert</code>、<code>update</code>、<code>delete</code>の合算した回数がしきい値を超えた場合にスケジュールされます。<p>閾値は自動解析と同様に<code>postgres.conf</code>のパラメータもしくはテーブルごとの設定値によって以下の計算式に従って計算されます。<pre><code>pg_stat.reltuples * autovacuum_analyze_scale_factor + autovacuum_analyze_threshold
</code></pre><h2>実例</h2><p>というわけで実例で確認してみます。<p>以下のクエリでテーブルごとの統計情報を確認できます。 （閾値はデフォルトの値を使用して計算しています。）<pre><code class="language-sql hljs"><span class=hljs-keyword>select</span> pc.relname,                                                     <span class=hljs-comment>-- テーブル名</span>
       reltuples,                                                      <span class=hljs-comment>-- 統計情報的にいるはずの行数</span>
       n_live_tup,                                                     <span class=hljs-comment>-- 統計情報的に生きてるはずの行数</span>
       n_dead_tup,                                                     <span class=hljs-comment>-- 統計情報的に死んでるはずの行数</span>
       n_mod_since_analyze,                                            <span class=hljs-comment>-- 前回統計を取った後に変わったっぽい行数</span>
       last_autoanalyze <span class=hljs-keyword>at</span> <span class=hljs-type>time</span> zone <span class=hljs-string>'Asia/Tokyo'</span> <span class=hljs-keyword>as</span> last_autoanalyze, <span class=hljs-comment>-- 最後にauto analyzeが走った時刻</span>
       last_autovacuum <span class=hljs-keyword>at</span> <span class=hljs-type>time</span> zone <span class=hljs-string>'Asia/Tokyo'</span>  <span class=hljs-keyword>as</span> last_autovacuum,  <span class=hljs-comment>-- 最後にauto vacuumが走った時刻</span>
       (reltuples <span class=hljs-operator>*</span> <span class=hljs-number>0.1</span>) <span class=hljs-operator>+</span> <span class=hljs-number>50</span>                     <span class=hljs-keyword>as</span> auto_analyze_thr, <span class=hljs-comment>-- auto analyzeが走る閾値</span>
       (reltuples <span class=hljs-operator>*</span> <span class=hljs-number>0.2</span>) <span class=hljs-operator>+</span> <span class=hljs-number>50</span>                     <span class=hljs-keyword>as</span> auto_vacuum_thr   <span class=hljs-comment>-- auto vacuumが走る閾値</span>
<span class=hljs-keyword>from</span> pg_class pc
         <span class=hljs-keyword>inner</span> <span class=hljs-keyword>join</span> pg_stat_all_tables psat <span class=hljs-keyword>on</span> pc.oid <span class=hljs-operator>=</span> psat.relid
<span class=hljs-keyword>where</span> pc.relname <span class=hljs-operator>=</span> <span class=hljs-string>'table01'</span>;
</code></pre><p>また、それぞれのパラメータのデフォルト値は以下の通りです。<table><thead><tr><th style=text-align:left>name<th style=text-align:left>setting<th style=text-align:left>description<tbody><tr><td style=text-align:left>autovacuum_analyze_scale_factor<td style=text-align:left>0.1<td style=text-align:left>Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples.<tr><td style=text-align:left>autovacuum_analyze_threshold<td style=text-align:left>50<td style=text-align:left>Minimum number of tuple inserts, updates, or deletes prior to analyze.<tr><td style=text-align:left>autovacuum_vacuum_scale_factor<td style=text-align:left>0.2<td style=text-align:left>Number of tuple updates or deletes prior to vacuum as a fraction of reltuples.<tr><td style=text-align:left>autovacuum_vacuum_threshold<td style=text-align:left>50<td style=text-align:left>Minimum number of tuple updates or deletes prior to vacuum.</table><p>これらのデフォルト値を使用した場合でも小規模なテーブルでは特に問題は起こさないと思います。<p>しかし、デフォルトの閾値が既存のテーブル行数に比例する形で計算されるため、例えば1億行のような非常に大きなテーブルになった場合においては自動バキュームが発動するまでの閾値が非常に大きくなります。 閾値が大きくなることにより自動バキューム間隔が伸びる・一度に処理するタプルが増えるためにパフォーマンスが明らかに劣化するなどの問題を発生させかねません。<p>カラム数によってテーブルのディスク上のサイズは大きく変わるので一概には言えませんが、6カラム・1億行のテーブルで大体ディスク上のサイズは15GBになります。 そのため、（単純に考えると）バキュームが発動するまでに16.5GBまでテーブルが肥大化することが予想されます。<p>そのため、特に大きな行数を含むテーブルに対しては以下の処置を行った方が良い場合があります。<ul><li>テーブルごとにパラメータを設定する。<li>夜間などに定期的に手動で<code>VACUUM</code>を実行する。</ul><p><a href=https://docs.microsoft.com/ja-jp/azure/postgresql/howto-optimize-autovacuum#optimize-autovacuum-per-table>テーブルごとに自動バキュームを最適化する</a><p>特に大きなテーブルの場合は、<code>autovacuum_vacuum_scale_factor</code>の値を<code>0</code>にしてしまい、代わりに<code>autovacuum_vacuum_threshold</code>を使用して固定行数で自動バキュームを発動させる方法もあります。<p>また、自動バキュームは当該行を参照可能なトランザクションが進行中の場合は何もできません。 そのため、ロングトランザクションが走っていると適切に不要行が回収されない可能性があります。<p>これは、自動バキュームに限らず手動で実行した場合にも当てはまります。<p>終わり</div></article><hr><nav class=post-navigation><ul><li><strong>Next: <a href=/posts/2021/wal-archive-and-pitr/ rel=next>PostgreSQLでもWALアーカイブを使用してPITRしたい</a> →</strong></ul></nav></main><footer><div><a href=/feed.xml> <svg viewbox="0 0 16 16" height=16 width=16 xmlns=http://www.w3.org/2000/svg><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"></path><path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"></path></svg> </a></div></footer>
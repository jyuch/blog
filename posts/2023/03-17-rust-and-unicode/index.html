<!doctype html><html lang=ja><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Rustでも文字数をカウントしたい - レンコン畑でつかまえて</title><meta content=Rustで異体字セレクタを含む文字列の文字数カウントを行う方法を解説します name=description><link href=/pagefind/pagefind-ui.css rel=stylesheet><link href=/styles.css rel=stylesheet><link href=/feed.xml rel=alternate title=レンコン畑でつかまえて type=application/atom+xml><link href=/feed.json rel=alternate title=レンコン畑でつかまえて type=application/json><script src=/pagefind/pagefind-ui.js></script><script>window.addEventListener('DOMContentLoaded',()=>{new PagefindUI({"element":"#search","showImages":false,"excerptLength":0,"showEmptyFilters":true,"showSubResults":false,"resetStyles":false,"bundlePath":"/pagefind/","baseUrl":"/"});});</script><body><nav class=navbar><a class=navbar-home href=/> <strong>レンコン畑でつかまえて</strong> </a><ul class=navbar-links><li><a href=/> Home </a><li><a href=/posts/> Archive </a><li><a href=https://about.jyuch.dev/> About Me </a></ul><div class=navbar-search><div id=search></div></div></nav><main class=body-post><article class=post data-pagefind-body><div class=post-header><h1 class=post-title>Rustでも文字数をカウントしたい</h1><nav class=post-tags><a class=tag href=/tags/rust/>rust</a><a href="/tags/character encoding/" class=tag>character encoding</a></nav><time datetime="2023-03-17 00:00:00" class=post-date> March 17th, 2023 </time></div><div class=post-body><h1>はじめに</h1><p>後輩にUnicodeを熱く語ったら引かれました。どうも弊社です<p>今まで結構Rustのコードを書いていましたが、そういえば日本語周りの挙動を確認していなかったなということで確認してみます。<h1>前提知識</h1><p>この辺はドキュメントに書いてあるので割と周知な内容なんじゃないかなという所ですが、Rustは内部的には文字列はUTF-8で扱っています。<p>背景は調べてないので知りません。 多分JSONのシリアライズ・デシリアライズとかで変換コストが減るとか、メモリ消費量を減らしたいとかなんとかじゃないでしょうか。<h1>文字数カウント</h1><p><code>String</code>には<code>pub fn len(&self) -> usize</code>なメソッドが生えていますが、このメソッドはバイト数を返してきます。 Rustのドキュメントは文字はUTF-8であることをしつこいくらい書いているので、納得できる挙動ではあります。<p>が、我々日本人は漢字を使わないといけない為、それでは困るわけです。<p>そこで、<code>pub fn chars(&self) -> Chars&lt;'_></code>なメソッドを呼び出して<code>char</code>のイテレータを取得し、その数を数えれば文字数をカウント出来ます。<pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-type>String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string>"Hello World"</span>);
<span class=hljs-keyword>let</span> <span class=hljs-variable>b</span> = <span class=hljs-type>String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class=hljs-string>"こんにちは"</span>);

<span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, a, a.<span class="hljs-title function_ invoke__">len</span>(), a.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());
<span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, b, b.<span class="hljs-title function_ invoke__">len</span>(), b.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());
</code></pre><pre><code class="language-shell hljs">Hello World 11 11
こんにちは 15 5
</code></pre><h1>本当にそれでいいの？</h1><p>ここまでの説明で、「<code>a.chars().count()</code>を呼び出せばいいのね！」と納得して帰る人は文字コードの怖さを知らない人です。 Unicode規格票で素振りを1000回やってから出直してきてください。<p>上の文をもう一度読んでみましょう。<blockquote><p><code>pub fn chars(&self) -> Chars&lt;'_></code>なメソッドを呼び出して<code>char</code>のイテレータを取得し、</blockquote><p>そうです。このメソッドは<code>char</code>、すなわちコードポイントのイテレータを返すに過ぎないわけです。<p>この方法だと「は（U+306F）」+「゜（U+309A）」で表現される「ぱ」は容赦なく2文字としてカウントされます。<pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-string>'は'</span>, <span class=hljs-string>'<span class="hljs-char escape_">\u</span>{309A}'</span>];
<span class=hljs-keyword>let</span> <span class=hljs-variable>a</span>: <span class=hljs-type>String</span> = a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">collect</span>();
<span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, a, a.<span class="hljs-title function_ invoke__">len</span>(), a.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());
</code></pre><pre><code class="language-shell hljs">ぱ 6 2
</code></pre><p>ソフトウェアエンジニア相手なら「内部的には2文字なんですよ～」と言えばいいだけ？ですが、一般人にそんなことを言っても「何言ってんだこいつ」となるだけです。<h1>Unicode正規化</h1><p>しかし、我々にはアクセント記号などを分解後再結合できるUnicode正規化という法具が存在します。<p>が、Rustの標準ライブラリに入ってません。 <a href=https://github.com/unicode-rs/unicode-normalization>unicode-normalization</a>を使うしかなさそうです。<pre><code class="language-toml hljs language-ini"><span class=hljs-section>[dependencies]</span>
<span class=hljs-attr>unicode-normalization</span> = <span class=hljs-string>"0.1"</span>
</code></pre><pre><code class="language-rust hljs"><span class=hljs-keyword>fn</span> <span class="hljs-title function_">test</span>(value: &<span class=hljs-type>Vec</span>&lt;<span class=hljs-type>char</span>>) {
    <span class=hljs-keyword>use</span> unicode_normalization::UnicodeNormalization <span class=hljs-keyword>as</span> _;

    <span class=hljs-keyword>let</span> <span class=hljs-variable>str</span>: <span class=hljs-type>String</span> = value.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">collect</span>();
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, <span class=hljs-type>str</span>, <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">len</span>(), <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());

    <span class=hljs-keyword>let</span> <span class=hljs-variable>str</span> = <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">nfc</span>().<span class="hljs-title function_ invoke__">to_string</span>();
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, <span class=hljs-type>str</span>, <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">len</span>(), <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());
}
</code></pre><pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-string>'は'</span>, <span class=hljs-string>'<span class="hljs-char escape_">\u</span>{309A}'</span>];
<span class="hljs-title function_ invoke__">test</span>(&a);
</code></pre><pre><code class="language-shell hljs">ぱ 6 2
ぱ 3 1
</code></pre><p>しかし、結合後の文字が収録されていない文字はやはりだめです。<pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-string>'か'</span>, <span class=hljs-string>'<span class="hljs-char escape_">\u</span>{309A}'</span>];
<span class="hljs-title function_ invoke__">test</span>(&a);
</code></pre><pre><code class="language-shell hljs">か゚ 6 2
か゚ 6 2
</code></pre><h1>Unicodeテキストセグメンテーション</h1><p>そこで、Unicode® Standard Annex #29 UNICODE TEXT SEGMENTATIONの出番です。<p>こいつでGrapheme Cluster Boundaries（書記素単位）でぶった切ってやればいいのです。<p>同じunicode-rsグループが開発している<a href=https://github.com/unicode-rs/unicode-segmentation>unicode-segmentation</a>クレートを使用します。<pre><code class="language-toml hljs language-ini"><span class=hljs-section>[dependencies]</span>
<span class=hljs-attr>unicode-segmentation</span> = <span class=hljs-string>"1"</span>
</code></pre><pre><code class="language-rust hljs"><span class=hljs-keyword>fn</span> <span class="hljs-title function_">test</span>(value: &<span class=hljs-type>Vec</span>&lt;<span class=hljs-type>char</span>>) {
    <span class=hljs-keyword>use</span> unicode_normalization::UnicodeNormalization <span class=hljs-keyword>as</span> _;
    <span class=hljs-keyword>use</span> unicode_segmentation::UnicodeSegmentation <span class=hljs-keyword>as</span> _;

    <span class=hljs-keyword>let</span> <span class=hljs-variable>str</span>: <span class=hljs-type>String</span> = value.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">collect</span>();
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, <span class=hljs-type>str</span>, <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">len</span>(), <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());

    <span class=hljs-keyword>let</span> <span class=hljs-variable>str</span> = <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">nfc</span>().<span class="hljs-title function_ invoke__">to_string</span>();
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, <span class=hljs-type>str</span>, <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">len</span>(), <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>());

    <span class=hljs-keyword>let</span> <span class=hljs-variable>g</span> = <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">graphemes</span>(<span class=hljs-literal>true</span>).collect::&lt;<span class=hljs-type>Vec</span>&lt;&<span class=hljs-type>str</span>>>();
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{} {} {}"</span>, <span class=hljs-type>str</span>, <span class=hljs-type>str</span>.<span class="hljs-title function_ invoke__">len</span>(), g.<span class="hljs-title function_ invoke__">len</span>());
}
</code></pre><pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-string>'か'</span>, <span class=hljs-string>'<span class="hljs-char escape_">\u</span>{309A}'</span>];
<span class="hljs-title function_ invoke__">test</span>(&a);
</code></pre><pre><code class="language-shell hljs">か゚ 6 2
か゚ 6 2
か゚ 6 1
</code></pre><p>なしとげました<p>これならみんな大好きIVSも正しくカウントできます。<pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-string>'<span class="hljs-char escape_">\u</span>{8FBB}'</span>, <span class=hljs-string>'<span class="hljs-char escape_">\u</span>{E0100}'</span>];
<span class="hljs-title function_ invoke__">test</span>(&a);
</code></pre><pre><code class="language-shell hljs">辻󠄀 7 2
辻󠄀 7 2
辻󠄀 7 1
</code></pre><pre><code class="language-rust hljs"><span class=hljs-keyword>let</span> <span class=hljs-variable>a</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-string>'<span class="hljs-char escape_">\u</span>{1F385}'</span>, <span class=hljs-string>'<span class="hljs-char escape_">\u</span>{1F3FF}'</span>];
<span class="hljs-title function_ invoke__">test</span>(&a);
</code></pre><pre><code class="language-shell hljs">🎅🏿 8 2
🎅🏿 8 2
🎅🏿 8 1
</code></pre><h1>おわりに</h1><p>文字コードを舐めると死にます</div></article><hr><nav class=post-navigation><ul><li>← Previous: <a href=/posts/2023/03-03-look-back-2022/ rel=prev>2022年の振り返りとか</a><li><strong>Next: <a href=/posts/2023/08-16-domain-transfer-google-domain-to-cloudflare/ rel=next>ドメインをGoogle DomainからCloudflareに移管したお話</a> →</strong></ul></nav></main><footer><div><a href=/feed.xml> <svg viewbox="0 0 16 16" height=16 width=16 xmlns=http://www.w3.org/2000/svg><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"></path><path d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"></path></svg> </a></div></footer>
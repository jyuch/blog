---
title: 生成AIを使って楽にリプレースしたい
description: 生成AIでプライベートプロジェクトのリプレースを行った際の記録です。
date: 2025-08-14
lastModified: 2025-08-14
tags: 
  - gen-ai
  - rust
---

# はじめに

お盆休みでまとまった時間が取れたので、生成AIを使ってプライベートプロジェクトのリプレースを行ったのでそのお話です。

個人的にはいわゆるバイブコーディングというものにあまり興味が無いのですが、触っておくと何か得られるかなということで触ってみることにしました。

# 環境

ちょうどgpt-ossが出てきたタイミングですので、ローカルマシンでgpt-oss-120bを動かして試してみることにしました。

- gpt-oss-120b
- LM Studio
- Visual Studio Code + Cline

過去に少しだけClineを触ったことがあったので、惰性でClineを選んでいます。

マシンのスペックは以下のような感じです。
GPUオフロードだとコンテキスト長が8kまでしか使えなかったので、GPUオフロードなしで全部CPUだけで動かします。

- AMD Ryzen™ 9 9950
- DDR5-5600 128GB

さすがにAPI経由で実行しているレベルでサクサクとは動きませんが、現実的な速度で動作してくれています。

ちなみにgpt-oss-120bは大体64GB位あります。
サイズがサイズなのでHDDに置いていますが、メモリに吸い込むまでに4分半位掛かります。

また、この記事を書いているタイミングでLM Studioの更新が降ってきて、ROCmランタイムでも128kコンテキストが扱えるようになっていました。
ですが、RT7800XTにGPUオフロード時は2.8トークン/秒で、CPUだけの14トークン/秒よりも圧倒的に遅いので、私の環境と似た環境を使っている方はCPUで回したほうがいいかもです。

# gpt-oss-120bの性能

普段からバイブコーディングをしている訳ではないので相対的な性能はなんともですが、少なくとも使い物にならないというレベルではないと思います。

試しに[WoLのマジックパケットを送出する簡単なコマンドラインツール](https://github.com/jyuch/2025-summer-holiday-project/tree/master/wakeonlan)を書かせてみましたが、そもそもClineで動かなかったりや明らかに変なコードを吐き出すということもなく、普通に書いてくれました。

また、clapなどのメジャーなライブラリであれば簡単な指示だけで使ってくれます。
ただ、この要件なら`subcommand`使ってほしいなという要件でも`enum`にマッピングしたりと、はっきりと明示しないと意図を汲んでくれなかったりするので、微妙な歩調のずれを感じるというのが正直なところです。

まぁ、この辺は使用するモデルによっても変わってくると思うので、将来的なモデルの進化に期待というところでしょうか。

# リプレース

簡単なツールを作れたので、次は本命のリプレース作業です。

今回のリプレースは、C#で書かれたデータベースアクセスとWeb APIを叩くツールをRustに置き換え、エラーハンドリングとリトライ処理を強化するのが目標です。

既存のコードがあるので、以下の順番で作業を行いました。

1. 既存リポジトリでClineに仕様書を書かせる
2. （自分で）リプレース先のCargoプロジェクトの作成
3. （自分で）必要なライブラリをインストールし、Tokioのmain関数を生やす
4. 1.で書かせた仕様書を読ませて（段階を踏んで）コードを書かせる

ライブラリを先行してインストールしたのは、`cargo.toml`を読ませて意図したコードを吐かせやすくするためです。
また、Tokio環境下であることを示すためにTokioのmain関数を予め生やしておきます。

関数レベルを書かせるならgpt-oss-120bでも十分に使えますが、以下の点がちょっと気になりました。

### 学習元のコードの手癖に引っ張られてる？

データベースにアクセスして`anyhow::Result<Some<Hoge>>`を返す関数を書かせている時の話です。

APIが`Some<Hoge>`を返してくる場合、その値をそのまま返せばいいと思いますが、なぜか`if let Some(hoge) = row`のようなパターンマッチをしたうえで改めて詰めなおすというロジックを吐いていました。

害は無いのですが、コーディングエージェントの仕組み上自分で書いたコードに引きずられるので、あまり好ましくないコードを書いてしまったら適宜修正させるか自分で直してしまったほうがいいのかもしれません。

また、周りのコードはちゃんとエラーハンドリングをしているのに、特定のライブラリを触る時だけ`.unwrap()`を呼び出すという挙動もしていました。
多分ブログのサンプルコードを学習しているのだとは思いますが、紛れ込まれるとトラップと化すので、コードの確認は必須だなぁと感じました。

### エラーの発生個所と原因の箇所が離れてると迷走する

今回のプロジェクトではデータベースアクセスにsqlxというライブラリを使用しています。

sqlxはクエリの結果を構造体にマップできるのですが、あらかじめ`#[derive(FromRow)]`を追加しないといけません。
追加しておかないと`sqlx::query_as`の呼び出し箇所で`Trait bound not satisfied`でコンパイルエラーとなります。

人間なら一度立ち止まって書き方を確認すると思いますが、Clineはコードをこねくり回してエラーを解消しようとするので無限にトークンが溶けていくと思います。

### ネストが深くなると迷走する

Rustは工夫なしでエラーハンドリングをすると`match`のネストがどんどん深くなってしまうのですが、そうするとカッコの対応が崩れてコンパイルエラーとなります。

`thiserror`などでエラーを集約させたうえで関数に分割していけばすっきりとしたコードにはなりますが、現時点では自発的にはやってくれないので、この辺も明示的に指示しないといけません。

### 指定してないライブラリを使おうとする

前述したとおり、使うライブラリを予めインストールして`cargo.toml`経由でClineが認識出来るようにしていたのですが、無視して別のライブラリをインストールしようとする場面が何度かありました。

今思えばこの辺りは`.clinerules`の書き方を工夫すれば回避できたかもしれません。

# おわりに

他のモデルは何ともですが、gpt-oss-120b君が吐き出すコードは有用ではある一方、品質があまりよくないコード片が紛れ込むので個人レベルのプロダクトでも鵜呑みにするのは危険かなというのが正直な感想です。

ただし、現状はモデルもコーディングエージェントも群雄割拠しているうえにベストプラクティスも確立出来ていないため、今回の結果をもってバイブコーディングを悲観視するのも違うかなと思います。

余談ですが、今回のリプレースではある程度コード片を生成させた後、使えるコード片だけ拾ってあとは全部作り直しました。

現時点では全部作らせるのは難しいので、単純だけど書くのがめんどくさいものを生成AIに作らせて、それ以外は人間が手書きするのも1つの手かもしれません。

おわり

{
  "version": "https://jsonfeed.org/version/1",
  "title": "レンコン畑でつかまえて",
  "home_page_url": "https://www.jyuch.dev/",
  "feed_url": "https://www.jyuch.dev/feed.json",
  "description": null,
  "author": {
    "name": "jyuch"
  },
  "items": [
    {
      "id": "https://www.jyuch.dev/posts/2025/08-29-ucd/",
      "url": "https://www.jyuch.dev/posts/2025/08-29-ucd/",
      "title": "Unicode Character Database の歩き方",
      "content_html": "<h1>はじめに</h1>\n<p>所用でUnicode Character Database（UCD）で調べ物をする必要があったのですが、Unicodeのサイトのググラビリティが恐ろしく低く調べるのに難儀したので、未来の自分のために残しておこうというｱﾚです。</p>\n<h1>Unicode® Standard</h1>\n<p><a href=\"https://www.unicode.org/standard/standard.html\">Unicode® Standard</a>はUnicodeの仕様についてのトップページです。</p>\n<p>最新のUnicodeの仕様は<a href=\"https://www.unicode.org/versions/latest/\">https://www.unicode.org/versions/latest/</a>から飛べます。</p>\n<h1>UAX #41: Common References for Unicode Standard Annexes</h1>\n<p><a href=\"https://www.unicode.org/reports/tr41/\">UAX #41: Common References for UAXs</a>は他のUAXへのリファレンスセットです。</p>\n<h1>UAX #44: Unicode Character Database</h1>\n<p><a href=\"https://www.unicode.org/reports/tr44/\">UAX #44: Unicode Character Database</a>で各テキストファイルの中身が解説されています。</p>\n<p>また、<a href=\"https://www.unicode.org/Public/\">https://www.unicode.org/Public/</a>から各UnicodeバージョンのUCDテキストファイルをダウンロードできます。</p>\n<h1>Unicode Utilities</h1>\n<p><a href=\"https://util.unicode.org/UnicodeJsps/index.jsp\">Unicode Utilities</a>はUCDの内容を確認するのに役に立ちます。</p>\n<p>特に<a href=\"https://util.unicode.org/UnicodeJsps/character.jsp\">Unicode Utilities: Character Properties</a>は文字のプロパティを確認する際に特に便利です。</p>\n<p>デフォルトで表示されているのが☕なのは、こんなページを確認するような人は正常ではなく、多量のカフェインを要しているということを暗示しているのでしょうか？</p>\n<p>おわり</p>",
      "date_published": "2025-08-29T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2025/07-13-2025-spring-nw/",
      "url": "https://www.jyuch.dev/posts/2025/07-13-2025-spring-nw/",
      "title": "ネットワークスペシャリスト試験に合格したお話",
      "content_html": "<h1>はじめに</h1>\n<p>去年の12月の<a href=\"https://www.jyuch.dev/posts/2024/12-28-2024-autumn-ap/\">応用情報技術者試験</a>に続きネットワークスペシャリスト試験に合格したのでそのお話です。</p>\n<p>特に言うこともないのですが、せっかく合格したので何か書いておこうというｱﾚです。</p>\n<p><s>こいついっつも試験受けてんな</s></p>\n<p><img src=\"https://www.jyuch.dev/img/2025/07-05-2025-spring-nw/result.png\" alt=\"\"></p>\n<h1>会場とか雰囲気とか</h1>\n<p>前回に引き続きつくばの国際会議場で受験しました。</p>\n<p>国際会議場でのネットワークスペシャリスト試験は２つ部屋に分かれていたので正確なところはわかりませんが、少なくとも私が受験したほうの部屋では午前Ⅰを受験されている人は居ませんでした。\nあの部屋の広さで午前Ⅰを自分一人で受験すると心が折れるかもしれません。</p>\n<p>年齢層はというと応用情報と比べると若干年齢層が上がり、20代後半から30代の人が一番多かったと思います。\nちらほら学生っぽい方もいて、学生時代はこのような試験を受けようとすら思わなかった私からするとすごいなと素直に感心してました。</p>\n<p>私はというと、会場で参考書を見てもそわそわして全く集中できないタイプなので、午前Ⅱが始まるまでイヤホンで音楽を聴きながらひたすらラムネをボリボリ食っている異常者と化していました。</p>\n<h1>アドバイス？</h1>\n<p>午後Ⅰ・Ⅱはいくつかある問題から解く問題を選択する形式ですが、悠長に悩んでいる暇はないのである程度スパっと決める必要があります。</p>\n<p>そこで、私は問題選択の方針として不得手な分野を優先して回避するというのをあらかじめ決めていました。</p>\n<p>私の得意不得意の傾向は証明書 ＞ ルーティング ＞ セキュリティ ＞ マルチキャスト ＞ VoIP ＞＞＞ 無線という順なので、なるべく無線は避けるといった具合です。</p>\n<p>また、個人的にはこういう試験を暗記で乗り切るのはちょっと違うかなと思っていますが、どのみち午後Ⅱとかいう暗記ではどうあがいても乗り切れない問題を解かないといけない事を考えると、少しでも午後問題の対策に勉強時間を割いたほうがいいと思います。\nそのうえで午前Ⅱを安定感をもって突破するなら暗記してしまうのも手だと思います。</p>\n<p>また、午後Ⅱ問題も過去数年分は何周かはしたほうがいいと思います。\nこれは問題と解答を覚えるというよりかは、問題文の日本語に慣れるという意味合いと、〇〇文字で述べよという記述に慣れるという意味合いがあります。</p>\n<p>個人的には過去問は午前Ⅱは10分、午後Ⅰは30分、午後Ⅱは60分位で解けていたので、細かい時間しか取れない平日は午前Ⅱや午後Ⅰ、まとまった時間が取れる休日に午後Ⅱを解くようにすると時間を有効に使えると思います。</p>\n<p>まぁ、結局は午後問題は自分が解きやすい問題が出ることを祈ることしかできないので、最終的には祈祷力が問われます。</p>\n<h1>試験の感想</h1>\n<h2>午前Ⅱ</h2>\n<p>全体的な問題構成は例年通りといったところで、ざっくりと前半に計算問題、真ん中あたりにネットワークの知識を問う問題、後ろのほうに一般的なIT知識を問う問題構成となっていました。</p>\n<p>計算問題は割と過去問からの出題が多かった気がします。\nですので、ある程度過去問をやりこんでいて計算問題の答えの数字を覚えている人は計算せずに答えられたのかなと思います。\n特に答えが80になる例のアーランの問題は出題間隔的に出てもおかしくなかったので、予想が見事に的中して嬉しかった（？）です。</p>\n<p>ただ、今回出ると予想していたOSコマンドインジェクションが出題されなかったので、次回は出ると思います。</p>\n<h2>午後Ⅰ</h2>\n<ol>\n<li><strong>ルータの更新（BGPとOSPF、VRRP）</strong></li>\n<li>ネットワークの改善（NATとHTTP/2・HTTP/3・QUIC）</li>\n<li><strong>セキュアWebゲートウェイ（パケットフィルタリングとルーティング、証明書）</strong></li>\n</ol>\n<p>午後Ⅰは１と３を選びました。\nというよりかは、２の図を見たときに「AP」という文字が飛び込んできて、とっさに「無線やんけ」と早とちりして回避した結果１と３になったという感じです。</p>\n<p>解いた感想としては１と３はよくある午後Ⅰ問題です。</p>\n<p>特にBGPとOSPFは近年よく出てきていたので、今年も出てくると予想していました。\nただ、こうも頻出されると来年は傾向を変えてくるんじゃないかと疑いたくもなりますね。</p>\n<h2>午後Ⅱ</h2>\n<ol>\n<li><strong>社内ネットワークのIPv6対応（IPv4・IPv6のデュアルスタック）</strong></li>\n<li>IoTシステム（LPWA・CoAP・DTLS）</li>\n</ol>\n<p>ついにIPv6が出題されてしまいました。</p>\n<p>正直今年出てくるとは思っていなかったのですが、IPv6なんか良さそうだな程度の理由で<a href=\"https://www.lambdanote.com/collections/ipv6\">ラムダノートさんのプロフェッショナルIPv6</a>を眺めていた時期があったので何とかなりました。</p>\n<p>内容の難易度としてはグローバルユニキャストアドレスとリンクローカルアドレスがありますよとか、ルーターアドバタイズメントでプレフィックスを広告してSLAACでGUAを決定しますよという内容で、<s>マニアックな内容ではないと思います。</s></p>\n<p>今書いていて思いましたが、上記の文もわからない人が見たら「オフチョベットしたテフをマブガッドしてリットにします」に通ずるものを感じますね。</p>\n<p>まぁ、「IPv6アドレスは〇〇ビットごとに：で区切る」の〇〇を答えよみたいな設問の下にIPv6アドレスの例が載っており、数えればわかるじゃんみたいな問題も出てきていました。</p>\n<p>とはいえ、IPv4とはお作法が異なる世界なので、事前にある程度雰囲気を掴んでおかないと試験時間だけで何とかするのは厳しいと思います。</p>\n<p>採点講評に『IPv6は普及が進んでいる技術なため、概要をしっかりと理解してほしい。』みたいなことを書かれると思うのと、今後は午後Ⅰに出題され始めると思うので概要だけでも掴んでおくといいと思います。</p>\n<h1>ネットワークスペシャリストは役に立つか</h1>\n<p>資格そのものを持っていると何か良いことがあるかというと、まぁ、特には無いのではないでしょうか。</p>\n<p>即金的な方面で言うと、会社によって変わると思うので一概には言えませんが、弊社の場合は合格すると中学生のお小遣い程度の奨励金が出ます。\n合格までに要した時間で時給換算すると最低賃金をぶっちぎる位の金額なので、単純にお金が欲しいなら勉強時間をタイミーに充てたほうがよっぽどお金になります。つらたにえん</p>\n<p>対して、よっぽどヤマを張る勉強方法とかで無ければネットワーク技術の割の広い範囲を勉強することになるので、普段自分が触らない技術についてある程度の理解は得られると思います。</p>\n<p>普段の仕事では触らないような範囲の知識についても勉強することになるので、広く浅くにはなりますが知識を得られるというのはかなり役に立つと思います。\nもちろん、ネスペの知識だけで仕事が出来るわけではありませんが、何かの調査をするときの起点としては十分役に立つと思います。</p>\n<h1>おわりに</h1>\n<p>IPv6アドレスを何度も手書きさせるのは正直やめてほしいッピ</p>\n<p>おわり</p>",
      "date_published": "2025-07-13T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2025/07-04-saa-c03/",
      "url": "https://www.jyuch.dev/posts/2025/07-04-saa-c03/",
      "title": "AWS Certified Solutions Architect - Associateに合格したお話",
      "content_html": "<h1>はじめに</h1>\n<p>AWS Certified Solutions Architect - Associateに合格したので、その話についてです。</p>\n<p><img src=\"https://www.jyuch.dev/img/2025/07-04-saa-c03/saa-c03.png\" alt=\"\"></p>\n<h1>モチベーション</h1>\n<p>本っ当にしょうもない理由なのですが、去年のAWS Summit Japanには認定者ラウンジというものが用意されていました。\n文字通りAWSの認定資格を持っている人が使えるというもので、使っている人たちを見て羨ましかったのを今でも覚えています。</p>\n<p>今年のAWS Summit Japanにも参加出来るということで、それならば今年こそは認定者ラウンジを利用したいと思い取得したのが動機となります。</p>\n<p>今年は認定者ラウンジはありませんでした。</p>\n<h1>誰がこの認定を取るべきか？</h1>\n<p>という半分冗談は置いておいて、どのような人がこの認定を取るべきでしょうか。</p>\n<p>弊社は事業会社ですので、その視点で見るとベンダーにAWSを使用したシステム構築を依頼する担当者は持っておいて損はないと思います。</p>\n<p>ベンダーに設計をお任せするとしても最終的な設計に対する責任はユーザー企業が負います。</p>\n<p>その時、ベンダーから設計に関する説明を受ける際に「フロントにはAWS くぁｗせｄｒｆｔｇｙふじこｌｐを使用します。」「はぁ？」のようにヤギと猫のネットミームを幻視するのはあまりよろしくありません。</p>\n<p>SAAでは主にサービスの種類や内容、そのサービスを利用する上での制限などが出題されます。\nつまり、SAAの内容を押さえておけばベンダーが使用を提案しているサービスの内容や制限がある程度分かるという訳です。</p>\n<p>もちろん、ベンダーの担当者がｱﾚでなければ聞けばサービスの内容などは教えてくれるとは思います。\nですが、いちいち聞くのは打ち合わせのテンポが悪くなりますし、「この人何もわかってないな」と思われるとベンダーの担当者の趣味全開の設計をブッ込まれる可能性もあります。</p>\n<h1>おわりに</h1>\n<p>認定シールをもらえたのでよしとします。</p>\n<p>おわり</p>",
      "date_published": "2025-07-04T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2025/05-10-new-main-pc/",
      "url": "https://www.jyuch.dev/posts/2025/05-10-new-main-pc/",
      "title": "メインPCを更新したお話",
      "content_html": "<h1>はじめに</h1>\n<p>メインPCを更新したのでそのことについてです。</p>\n<h1>モチベーション</h1>\n<p>使っているメインPCは大体7年前位に購入したもので、以下の問題を抱えていました。</p>\n<ul>\n<li>Windows 11のサポート対象外で2025年10月以降は実質使えなくなる</li>\n<li>検証用に仮想マシンをいくつか立ち上げた時に、CPUの処理が明らかに追いついていない時がある</li>\n<li>モンハンワイルズが動かない</li>\n</ul>\n<p>特にWindows 11のサポート対象外は流石にまずいので、直前に慌てるよりは少し余裕を持って更新しようというのが動機となります。</p>\n<h1>次期PCに求める要件</h1>\n<p>現行PCは主に検証用に仮想マシンを立てる使い方をしており、その使い方は踏襲します。\nまた、瞬発的な処理能力も欲しいところです。</p>\n<p>そのため、次期PCに求める要件は以下の通りとなりました。</p>\n<ul>\n<li>CPU\n<ul>\n<li>なるべく高い周波数で動作するマルチコアなCPUを採用する</li>\n</ul>\n</li>\n<li>メモリ\n<ul>\n<li>現行PCの倍となる128GBを最低とする</li>\n</ul>\n</li>\n<li>ストレージ\n<ul>\n<li>OSを格納する高速で動作するプライマリストレージ</li>\n<li>仮想マシンを格納するSSDベースのセカンダリストレージ</li>\n<li>アーカイブを格納するHDDベースの大容量ストレージ</li>\n</ul>\n</li>\n</ul>\n<p>こんな変な構成のPCは市販どころかBTOでも組めなさそうなので当然のように自作することになります。</p>\n<h1>選定パーツ</h1>\n<p>要件が固まったらパーツを選定していきます。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">コンポーネント</th>\n<th style=\"text-align:left\">メーカー</th>\n<th style=\"text-align:left\">モデル</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">CPU</td>\n<td style=\"text-align:left\">AMD</td>\n<td style=\"text-align:left\">Ryzen™ 9 9950X</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">メモリ</td>\n<td style=\"text-align:left\">Crucial</td>\n<td style=\"text-align:left\">Pro 128GB Kit (64GBx2) DDR5-5600 UDIMM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">プライマリストレージ</td>\n<td style=\"text-align:left\">Sandisk</td>\n<td style=\"text-align:left\">WD_BLACK SN850X 1TB</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">セカンダリストレージ</td>\n<td style=\"text-align:left\">Solidigm</td>\n<td style=\"text-align:left\">P41 Plus 2TB</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">マザーボード</td>\n<td style=\"text-align:left\">ASUS</td>\n<td style=\"text-align:left\">Prime X870-P WIFI-CSM</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CPUクーラー</td>\n<td style=\"text-align:left\">ARCTIC</td>\n<td style=\"text-align:left\">Liquid Freezer III - 360</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PCケース</td>\n<td style=\"text-align:left\">Fractal Design</td>\n<td style=\"text-align:left\">North XL</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">電源</td>\n<td style=\"text-align:left\">Corsair</td>\n<td style=\"text-align:left\">RM850e</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GPU</td>\n<td style=\"text-align:left\">ASRock</td>\n<td style=\"text-align:left\">RT7800XT Challenger 16GB OC</td>\n</tr>\n</tbody>\n</table>\n<h2>CPU</h2>\n<p>最近のIntel CPUはPコアと呼ばれる高い処理能力を持つコアとEコアと呼ばれる高効率コアの二つのコアのハイブリット構成となっています。</p>\n<p>理念としては理解できるのですが、どうやらVMWare Workstation Proでコア間のスケジューリングに問題を抱えているという話をちらっと聞いたり、私自身もその周りでトラブルを抱えたくないなぁという思いから今回はAMDのCPUを採用することとしました</p>\n<p>特に<a href=\"https://www.amd.com/ja/products/processors/desktops/ryzen/9000-series/amd-ryzen-9-9950x.html\">AMD Ryzen™ 9 9950X</a>は全部Pコア、コアいっぱい、高いクロック数というバカの考えた最強のCPUを地で行っており、要件的に最も近いためこちらを採用することとします。</p>\n<p>なお、9950X君には上位存在の9950X3Dという3D V-Cacheを積んでいるモデルもありますが、売ってないものは買えないのと、別にゲーム性能はそこまで求めてないので今回は採用しませんでした。</p>\n<h2>メモリ</h2>\n<p>9950XはDDR5メモリ対応なのですが、4枚刺しだとメモリクロックが下がってしまうため出来れば2枚で運用したいところです。</p>\n<p>と思いながらネットショップを徘徊していたら<a href=\"https://www.crucial.jp/memory/ddr5/cp2k64g56c46u5\">Crucial Pro 128GB Kit (64GBx2) DDR5-5600 UDIMM</a>の在庫が復活していたのでお買い上げしました。</p>\n<h2>ストレージ</h2>\n<p>プライマリストレージとして<a href=\"https://shop.sandisk.com/ja-jp/products/ssd/internal-ssd/wd-black-sn850x-nvme-ssd?sku=WDS100T2X0E-00BCA0\">Sandisk WD_BLACK SN850X 1TB</a>、セカンダリストレージとして<a href=\"https://www.solidigmtechnology.jp/products/client/plus-series/p41.html\">Solidigm P41 Plus 2TB</a>を選択しました。</p>\n<p>ターシャリのHDDは家で余っていた4TBのHDDをWindows記憶域で2本ミラーで束ねて使っています。</p>\n<h2>マザーボード</h2>\n<p>上記のCPU、メモリ、ストレージが刺さるマザーボードで必要十分な性能を持つ（と思った）<a href=\"https://www.asus.com/jp/motherboards-components/motherboards/csm/prime-x870-p-wifi-csm/\">ASUS Prime X870-P WIFI-CSM</a>を採用します。</p>\n<h2>CPUクーラー</h2>\n<p>AMDのデータシート曰く、</p>\n<blockquote>\n<p>Liquid cooler recommended for optimal performance</p>\n</blockquote>\n<p>とのことなので、今回は簡易水冷クーラーを投入することとしました。</p>\n<p>簡易水冷は消耗部品ということらしいので、そこそこの値段で評判のよさそうな<a href=\"https://www.arctic.de/en/Liquid-Freezer-III-360/ACFRE00136A\">ARCTIC Liquid Freezer III - 360</a>を採用します。</p>\n<p>なお、このモデルはクーラーヘッドの上に周辺パーツの冷却用のファンが載っているのですが、マザーボードによっては干渉してしまうこともあるようなので事前に確認してから買うと良いと思います。</p>\n<p>また、私が買ったときはCPUグリスのMX6が添付されていましたので、確認してから買うと無駄に別途CPUグリスを買ってしまう悲劇をさけられると思います。（1敗）</p>\n<h2>PCケース</h2>\n<p>今回採用した簡易水冷クーラーのラジエータサイズが360mmと大型なので、このラジエータを無理なく納められるケースとして<a href=\"https://www.fractal-design.com/ja/products/cases/north/north-xl/chalk-white/\">Fractal Design North XL</a>を採用しました。</p>\n<p>見た目もいいかんじです。</p>\n<h2>電源</h2>\n<p>電源は今まで使ってきて安心感のあるCorsairから選びました。</p>\n<p>多分850Wあれば足りるだろうということで<a href=\"https://www.corsair.com/jp/ja/p/psu/cp-9020296-jp/rme-series-rm850e-fully-modular-low-noise-atx-power-supply-jp-cp-9020296-jp\">Corsair RM850e</a>をチョイス。</p>\n<h2>GPU</h2>\n<p>なんとなく目についたので<a href=\"https://asrock.com/Graphics-Card/AMD/Radeon%20RX%207800%20XT%20Challenger%2016GB%20OC/index.jp.asp\">ASRock RT7800XT Challenger 16GB OC</a>をチョイス。</p>\n<p>Challengerとはどの立ち位置のブランドなのか、オーバークロックだと何が変わるのか、何も分からずに使っています。</p>\n<p>モンハンが動けばいいんすよ</p>\n<h1>組み立て</h1>\n<p>North XLはサイズは大きいですが内部の容積も大きく、大型の簡易水冷でも無理なく取り回せます。\nそのため、初めて簡易水冷で組みましたがとくにトラブルも無く組むことが出来ました。</p>\n<h2>好きなインシュロック発表ドラゴン</h2>\n<p>マザーボードなどのパーツには結束バンドが何本か添付されていますが、今回の組み立てでは別途購入した<a href=\"https://www.hellermanntyton.co.jp/product/cabletie/a01_ab/ab_w.html\">AB80-W</a>を使用しました。\nホームセンターでも一つ300円程度で売られていると思います。</p>\n<p>たくさん用意しておくとケーブルのハンドリングをするのに気兼ねなく使えます。\nまた、PCケースにケーブルを固定する際にも先端に角度が付けられているので結束しやすいという利点もあります。</p>\n<p>今回の組み立て作業時の組み立てやすさの何割かはインシュロックに助けられている部分があるので、個人的にはおすすめのPCパーツ（？）です。</p>\n<h2>初回起動時の起動時間</h2>\n<p>容量の大きなメモリを積むと初回起動時に画面が表示されるまで時間が掛かると言われていましたが、この構成ではたしか10分位で最初の表示が行われていたと思います。</p>\n<h1>インストール</h1>\n<p>あとは普通にWindowsとドライバをインストールすれば完了です。</p>\n<p>ドライバはASUS DriverHubというものでマザーボード用ドライバをインストールした後、AMD Software: Adrenalin Edition経由でチップセットドライバとグラボドライバを更新しました。\nこれが正しい手順かどうかはよくわかっていません。</p>\n<h1>ベンチマーク</h1>\n<p>最後に性能を測ります。</p>\n<p>よくあるのはCinebenchですが、まぁ自作のツールでベンチマークしてもいいよねって事で<a href=\"https://www.jyuch.dev/posts/2025/01-02-shrink-image-size-using-rust/\">自作の画像変換ツール</a>の処理時間で確認してみましょう。</p>\n<pre><code class=\"language-txt\">&gt; Measure-Command { cwebp.exe -i .\\input\\ -o .\\output\\ }\n\n\nDays              : 0\nHours             : 0\nMinutes           : 10\nSeconds           : 52\nMilliseconds      : 837\nTicks             : 6528379424\nTotalDays         : 0.0075559947037037\nTotalHours        : 0.181343872888889\nTotalMinutes      : 10.8806323733333\nTotalSeconds      : 652.8379424\nTotalMilliseconds : 652837.9424\n</code></pre>\n<pre><code class=\"language-txt\">&gt; Measure-Command { cwebp.exe -i .\\input\\ -o .\\output\\ }\n\n\nDays              : 0\nHours             : 0\nMinutes           : 3\nSeconds           : 2\nMilliseconds      : 843\nTicks             : 1828432412\nTotalDays         : 0.00211624121759259\nTotalHours        : 0.0507897892222222\nTotalMinutes      : 3.04738735333333\nTotalSeconds      : 182.8432412\nTotalMilliseconds : 182843.2412\n</code></pre>\n<p>同じ画像セットに対して処理を行いました。\n11分から3分と大体3.6倍の性能向上となっています。</p>\n<p>なお、9950Xの方はCPUの使用率が30～50%のあたりをうろうろしていました。\nこの辺は私の作りこみが甘い部分があるのでもう少し頑張ればもっと性能差は開きそうです。</p>\n<h1>おわりに</h1>\n<p>これからはこのメインPC君にいろいろ頑張ってもらいましょう。</p>\n<p>おわり</p>",
      "date_published": "2025-05-15T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2025/01-19-determine-color-or-monochrome/",
      "url": "https://www.jyuch.dev/posts/2025/01-19-determine-color-or-monochrome/",
      "title": "Rustでも画像がカラーかモノクロか判別したい",
      "content_html": "<h1>はじめに</h1>\n<p><a href=\"https://www.jyuch.dev/posts/2025/01-02-shrink-image-size-using-rust/\">前回</a>では画像をavifにして縮小する方法を確認したのですが、よくよく確認してみると明らかにモノクロ画像なのにカラープロファイルで保存されている画像とかもちらほらあったんですよね。</p>\n<p>じゃあカラー画像かモノクロ画像か判別して、モノクロならビット深度を8bitに落とせばもっとサイズを縮小出来るのではということでカラーかモノクロか判別する方法を確認してみました。</p>\n<p><a href=\"https://takuya-1st.hatenablog.jp/entry/2023/04/05/230317\">画像が、白黒かカラーか判定する。(白黒に近いスキャン画像を判定する）- それマグで！</a></p>\n<p>HSV（HSB）色空間に変換して、S(Saturation)×V(Value)の値を閾値で2値化してその平均値で判定すればうまく行くとのことです。</p>\n<h1>HSV色空間</h1>\n<p>さて、前回に引き続き画像ライブラリにはimage-rsを使っているので、HSV色空間に変換するメソッドがあれば一発で終わります。ありませんでした</p>\n<p>ただ、RGBからHSVに変換するのはそんなに難しくないので、ここでは愚直に実装していきます。</p>\n<p>RGB用に以下の<code>max</code>、<code>min</code>なヘルパメソッドを定義して、</p>\n<pre><code class=\"language-rust\">fn max(r: u8, g: u8, b: u8) -&gt; u8 {\n    if r &gt; g &amp;&amp; r &gt; b {\n        r\n    } else if g &gt; b &amp;&amp; g &gt; r {\n        g\n    } else {\n        b\n    }\n}\n\nfn min(r: u8, g: u8, b: u8) -&gt; u8 {\n    if r &lt; g &amp;&amp; r &lt; b {\n        r\n    } else if g &lt; b &amp;&amp; g &lt; r {\n        g\n    } else {\n        b\n    }\n}\n</code></pre>\n<p>定義通りにSとVを計算するメソッドを実装します。\nなお、値域は文献によってまちまちなのですが、ここでは0から255までとして計算しています。</p>\n<p>また、今回の計算ではHは使用しないので実装していません。</p>\n<pre><code class=\"language-rust\">fn v(r: u8, g: u8, b: u8) -&gt; u8 {\n    max(r, g, b)\n}\n\nfn s(r: u8, g: u8, b: u8) -&gt; u8 {\n    let v = v(r, g, b);\n\n    if v == 0 {\n        0\n    } else {\n        (255f64 * ((max(r, g, b) as f64 - min(r, g, b) as f64) / max(r, g, b) as f64)) as u8\n    }\n}\n</code></pre>\n<h1>判定</h1>\n<p>あとは画像を読み込んで1ピクセル毎にHSV色空間に変換して閾値から2値化して平均すれば完了です。</p>\n<pre><code class=\"language-rust\">fn is_monochrome(img: &amp;DynamicImage) -&gt; f64 {\n    let img = img.clone().into_rgb8();\n    let mut sum = 0u32;\n    let mut n = 0u32;\n\n    // 2値化するときの閾値（今回は10%を使用している）\n    let threshold = (256f64 * 256f64 * 0.1) as u32;\n    for (_, _, pixel) in img.enumerate_pixels() {\n        let r = pixel.0[0];\n        let g = pixel.0[1];\n        let b = pixel.0[2];\n\n        // HSV色空間に変換\n        let v = v(r, g, b);\n        let s = s(r, g, b);\n        let sv = s as u32 * v as u32;\n\n        // 2値化\n        if sv &gt; threshold {\n            sum += 1;\n        }\n        n += 1;\n    }\n    \n    // 平均を計算\n    let mean = sum as f64 / n as f64;\n    mean\n}\n</code></pre>\n<p>結果が0よりも大きければカラー、0ならモノクロと判別出来ると思います。たぶん</p>\n<p><a href=\"https://github.com/jyuch/is-monochrome\">is-monochrome</a></p>\n<p>おわり</p>",
      "date_published": "2025-01-19T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2025/01-02-shrink-image-size-using-rust/",
      "url": "https://www.jyuch.dev/posts/2025/01-02-shrink-image-size-using-rust/",
      "title": "RustでもAVIFフォーマットに変換して画像サイズを縮小したい",
      "content_html": "<h1>はじめに</h1>\n<p>Rustとimage-rsを使ってjpeg画像などをAVIFフォーマットに変換して画像サイズを縮小するツールを作成したのでそれについてです。</p>\n<p><a href=\"https://github.com/jyuch/cwebp\">cwebp</a></p>\n<p>自炊したスキャン画像があり、普段はPCで参照していたのでWindows標準の画像ビューワで見ていました。\nしかし、諸般の事情で手元のiPhoneでも見れたほうがいいよねってことで画像ファイルを本ごとにブラウザで見れるようにSSGを使ってHTMLに起こしました。</p>\n<p>宅内からでしか参照しないのでオリジナルサイズの画像をそのまま貼り付けても良かったのですが、画像数が32000程度あり取り回しやサーバへの転送でつらみポイントが高めだったので、ナウでヤングなファイルフォーマットを使って取り回しを良くしたいというのが作った動機です。</p>\n<p>また、単純に画像を変換するだけならImageMagicを使えば良いと思いますが、画像を保存しているディレクトリ構造を保ったまま一括で変換してほしかったのでツールを作成しました。</p>\n<p>最初はWebPフォーマットにしようとしましたが、ビット深度を落としてもオリジナルサイズの2倍くらいのサイズになってしまうのでAVIFフォーマットに切り替えたという経緯があります。</p>\n<h1>使用ライブラリ</h1>\n<p>Rustでの画像操作ライブラリは<a href=\"https://github.com/image-rs/image\">image-rs</a>を使っています。</p>\n<p>オリジナルファイルは残す前提なので、ファイルサイズを縮小することを優先して変換を掛けています。</p>\n<p>書籍系の画像なのでアルファチャネルは不要で、カラーはRGBでビット深度が24bit、モノクロははビット深度を8bitに落としています。</p>\n<p>image-rsは書き出し時に指定するパスのファイルの拡張子からフォーマットを決めてくれるので、出力パスを決定する段階で拡張子<code>.avif</code>を付けています。</p>\n<p>また、これは完全に私の管理が悪いのですが、たまに拡張子とファイルフォーマットが一致していないファイルがあったりします。\nそのため、画像を読み込むときは拡張子から読み込むフォーマットを決めているのではなく、ファイルから読み込んだ中身からファイルフォーマットを類推させています。</p>\n<p>あとは、画像サイズをコマンドラインパラメータから指定できるようにし、画像サイズの縮小も同時に行っています。</p>\n<pre><code class=\"language-rs\">fn convert(\n    input: impl AsRef&lt;Path&gt;,\n    output: impl AsRef&lt;Path&gt;,\n    width: Option&lt;u32&gt;,\n    height: Option&lt;u32&gt;,\n) -&gt; anyhow::Result&lt;()&gt; {\n    let content = fs::read(&amp;input)?;\n    let img = ImageReader::new(Cursor::new(&amp;content))\n        .with_guessed_format()?\n        .decode()?;\n\n    let (cur_width, cur_height) = img.dimensions();\n    let new_width = width.unwrap_or(cur_width);\n    let new_height = height.unwrap_or(cur_height);\n    let img = img.resize(new_width, new_height, FilterType::Lanczos3);\n\n    let img: DynamicImage = match img.color() {\n        ColorType::L8 | ColorType::La8 | ColorType::L16 | ColorType::La16 =&gt; {\n            DynamicImage::from(img.into_luma8())\n        }\n        ColorType::Rgb8\n        | ColorType::Rgba8\n        | ColorType::Rgb16\n        | ColorType::Rgba16\n        | ColorType::Rgb32F\n        | ColorType::Rgba32F =&gt; DynamicImage::from(img.into_rgb8()),\n        _ =&gt; unreachable!(),\n    };\n\n    img.save(output)?;\n    Ok(())\n}\n</code></pre>\n<h1>縮小比と処理時間</h1>\n<p>AVIFフォーマットの画像縮小は効果てきめんで、カラーならオリジナル比で40%、モノクロで60%くらいまで縮んでくれます。</p>\n<p>ただし、処理時間がWebPフォーマットなどの比べるととても遅く、1ファイル当たり平均で811msくらい掛かります。\nPNGなどが大体14mくらいなので、まぁ、うん、その、ねぇ・・・</p>\n<p>おわり</p>",
      "date_published": "2025-01-02T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2024/12-31-look-back-2024/",
      "url": "https://www.jyuch.dev/posts/2024/12-31-look-back-2024/",
      "title": "2024年の振り返りとか",
      "content_html": "<h1>はじめに</h1>\n<p>2024年の振り返りです。</p>\n<h1>Rust</h1>\n<p>プライベートでもあまり書けていませんでしたが、<a href=\"https://github.com/jyuch/advoid\">advoid</a>のようにある程度実用的なプログラムを形に出来たのは良かったのかもしれません。\nadvoidは宅内のあまり重要ではない端末に対してDNSを提供していますが、今のところ問題を起こさずに安定して動いています。</p>\n<p>来年はRustをメインで書けるようなお仕事を探してみても良いのかなと思っています。</p>\n<h1>資格とか</h1>\n<p><a href=\"https://www.jyuch.dev/posts/2024/12-28-2024-autumn-ap/\">今年は勘違いから応用情報を受験</a>しました。</p>\n<p>勘違いで受験したのはもう少し確認しろよの一言ですが、会場の雰囲気が分かったり来年受けようと思っているネスペの午前Ⅰが免除になったので全体的には良かったのかなと思います。</p>\n<p>ある程度の実務経験があるエンジニアならあんまり勉強しなくても合格出来ると思うので、試しに受験してみるのもいいかもしれません。</p>\n<h1>ブログ</h1>\n<p>今のドメインに移行して2年位まともにGoogleにインデックスされませんでしたが、最近インデックスされるようになりました。\n特に何かをいじったわけではないので、インデックスされない期間が終わったということなんだと思います。</p>\n<p>だから何だというわけではないのですが、今後は検索に引っかかるようになるので私がうれしいというお話です。</p>\n<p>あと、最近は記事をあまり書いてこなかったのですが、そのせいか昔に比べて文章を書く能力が低下している気がしています。\n接続詞や言い回しがパッと出てこないんですよね。</p>\n<p>なので、今年は記事を書くペースを上げていきたいです。</p>\n<h1>おわりに</h1>\n<p>来年も良い感じに頑張りたいと思います。</p>",
      "date_published": "2024-12-31T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2024/12-28-2024-autumn-ap/",
      "url": "https://www.jyuch.dev/posts/2024/12-28-2024-autumn-ap/",
      "title": "応用情報技術者試験に合格していたお話",
      "content_html": "<h1>はじめに</h1>\n<p>2024年秋の応用情報技術者試験を受験して合格していたのでそのお話です。</p>\n<p>それなりに実務経験を積んではいるがめんどくさくて基本情報や応用情報を今まで受けてこなかった人が、気まぐれや必要に迫られて受けることになった際に参考になるように記録として残しておこうと思います。</p>\n<p><img src=\"https://www.jyuch.dev/img/2024/12-28-2024-autumn-ap/result.png\" alt=\"\"></p>\n<h1>受験した経緯</h1>\n<p>私の本業はアプリケーション開発なのですが、仕事ではネットワークに触れる機会がそれなりに多いという謎の経歴を持っています。\nそれじゃということで勉強がてらネットワークスペシャリストが欲しいなと思っていました。</p>\n<p>それで私は何を勘違いしていたのか、高度情報処理技術者試験は応用情報技術者が前提になっていると勘違いしていました。\n多分応用情報を持っていれば午前Ⅰの試験が免除になるという話と混ざっていたのだと思います。</p>\n<p>そんなこともあり、ロクに調べることもなく応用情報技術者試験を申し込んでしまったというのが事の経緯となります。</p>\n<h1>試験会場の雰囲気</h1>\n<p>私はつくばの国際会議場で受験したので、他の会場のだと勝手が違うかもしれませんので最初に断っておきます。</p>\n<p>会場には受付があるのかなと思っていましたが、「APはあちら」位の案内が貼ってあるだけでした。</p>\n<p>また、試験室には試験開始30分前？位までは入れないので、あまり早く到着しても無駄にソワソワするだけです。\n入室できる時間になると案内がされるので、受験票の番号にしたがって部屋に入って指定された席に着くという感じです。</p>\n<p>なお、ホテルを借りた会場では机と椅子の高さが合ってないみたいなツイートがありましたが、普通の机と普通の椅子で特にそんなことはなく、さすが国際会議場といったところです。</p>\n<p>コンビニが微妙に遠いので、お昼ご飯はあらかじめ買っておいたほうが無難です。\nあと、午後試験の直前はトイレがめっちゃ混みます。気を付けましょう</p>\n<h1>試験の難易度</h1>\n<h2>午前試験</h2>\n<p>範囲が広いので過去問をまんべんなくやっておいたほうがいいかもしれません。\nただし、選択式なのでその分野を深く知っておくというよりかは単語とその意味を知っているか位の感じで良いと思います。\nまぁ、参考書を1～2周して、ちょっと苦手な部分を重点的にやっておく位で大丈夫です。</p>\n<p>また、割と時流を抑えているようで、2024年の秋試験ではオブジェクトストレージやLLMのファインチューニングを問う問題が出ていました。\n対して、昔のメインフレームの文脈で使われることの多かったデュプレックスシステムやデュアルシステムは出てこなかった気がします。\n今後はクラウド系の知識を問う問題が増えると思います。</p>\n<p>待ち行列や2分探索木、ハッシュ関数や逆ポーランド記法などの鉄板はやっておいたほうが良いです。出ます</p>\n<h2>午後試験</h2>\n<p>カテゴリが選択式で範囲が狭まる分、午前よりは深い理解を問われます。</p>\n<p>とはいえ、セキュリティならパスワードのハッシュ化や組み合わせの数、ネットワークならパケットフィルタやルーティングテーブルなどそのカテゴリの基本的な知識を問うレベルですのでそんなに身構えなくても良いかもです。</p>\n<p>カテゴリは決まっているようなので、自分が得意とする分野をあらかじめ見繕って勉強しておけば良いんじゃないかなと思います。</p>\n<p>あと、漢字〇文字で書け系の問題も割と出ます。\n私は「多層防御」の「御」を思い出せずに帰りの迎えの車の中で思い出しました。</p>\n<p>また、午後試験は割と焦りやすいので落ち着いて問題文を読むようにしたほうが良いですね。\n私も焦って解いて見直しで結構手直しをすることが多かったです。</p>\n<p>おわり</p>",
      "date_published": "2024-12-28T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2024/12-20-openjdk-self-build/",
      "url": "https://www.jyuch.dev/posts/2024/12-20-openjdk-self-build/",
      "title": "WindowsでもOpenJDKを野良ビルドしたい",
      "content_html": "<h1>はじめに</h1>\n<p>OpenJDKの中身をいじって検証する必要があったので、WindowsでOpenJDKを野良ビルドする方法を確認してみました。</p>\n<p>最新のバージョンなら<a href=\"https://openjdk.org/groups/build/doc/building.html\">OpenJDKの公式Wikiのビルドのページ</a>を参照すればいいですが、古いバージョンはリポジトリ内の<code>docs</code>フォルダの中身を確認する必要があります。（1敗）</p>\n<p>また、基本的にバージョンが下るほどビルド難易度が上がっていきます。</p>\n<p>古いバージョンだと過去のVisual StudioとかWindowsバージョンが必要っぽいですが、流石に個人でVisual Studio Subscriptionを契約していないので基本的にWindows 11 + Visual Studio 2022でビルドしていきます。</p>\n<h1>必要なもの</h1>\n<p>OpenJDKの公式リファレンス曰く、英語版のWindowsのみを公式でサポートしているらしいです。\nそのため、何らかの合法的な手段で英語版のWindowsを調達するか、ロケールを英語に変更してください。</p>\n<p>そうしたら以下の開発ツールをインストールします。</p>\n<ul>\n<li>Visual Studio 2022\n<ul>\n<li>「Desktop development with C++」ワークロード</li>\n</ul>\n</li>\n<li>Cygwin\n<ul>\n<li>autoconf</li>\n<li>make</li>\n<li>zip</li>\n<li>unzip</li>\n</ul>\n</li>\n<li>git（GitHubからソースをクローンしてくるなら）</li>\n<li>ビルド済みのJDK（ビルドしたいOpenJDKのバージョンかその一つ前のバージョン）</li>\n<li>JTReg（リグレッションテストを回すなら）</li>\n<li>googletest（hotspotのテストを回すなら）</li>\n</ul>\n<p>ソースをzipで落としてくるのであれば、ファイル数がとても多いので7zipなどのアーカイバを使って解凍したほうがいいかもしれません。</p>\n<h1>ビルド</h1>\n<p>どのバージョンでも<code>build\\windows-x86_64-server-release\\jdk</code>にバイナリが吐かれています。</p>\n<p>大体どのバージョンでも手元のマシンだとビルドで30分位、<code>test-tier1</code>で2時間位掛かるのでゆっくりしていってね！！！</p>\n<p>あと、ビルドに時間が掛かるからって調子に乗って複数バージョンの同時ビルドを流すと、たまにテストがタイムアウトしてError扱いになるので注意しましょう。（4敗）</p>\n<h2>OpenJDK 23 (23.0.1-11)</h2>\n<p>最新ならとっても簡単です。</p>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-23.0.1+11 \\\n--with-jtreg=/cygdrive/c/java/jtreg \\\n--with-gtest=/cygdrive/c/src/googletest-1.14.0\n</code></pre>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 22 (22.0.2-9)</h2>\n<p>22までならなんの捻りもなくビルドが通ります。</p>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-22.0.2+9 \\\n--with-jtreg=/cygdrive/c/java/jtreg \\\n--with-gtest=/cygdrive/c/src/googletest-1.14.0\n</code></pre>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 21 (21.0.6-6)</h2>\n<p>最新のLTSですが、googletestを有効にするとビルドに失敗するようになります。\nここから雲行きが怪しくなります。</p>\n<p>とりあえずバイナリが欲しいので、googletestを無効にしてビルドを進めます。</p>\n<pre><code class=\"language-sh\"> bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-21.0.5+11 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<p>googletestを無効化したせいでいくつかのhotspotテストが失敗として報告されますが、動くので多分問題ないでしょう。</p>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 20 (20.0.2-ga)</h2>\n<p>ビルド中にワーニング出てきて若干不穏な感じになりますが、まぁビルドが通るので良しとしましょう。</p>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-20.0.2+9 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<p>20からgoogletest起因以外でテストが1件失敗し始めます。</p>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 19 (19.0.2-ga)</h2>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk/cygdrive/c/java/jdk-19.0.2+7 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 18 (18.0.2.1-0)</h2>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-18.0.2.1+1 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 17 (17.0.14-6)</h2>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-17.0.13+11 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<pre><code class=\"language-sh\">make all; make test-tier1\n</code></pre>\n<h2>OpenJDK 16 (16.0.2-ga)</h2>\n<p>Visual Studioのビルド環境の検出に失敗して<code>bash configure</code>自体が失敗します。</p>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-16.0.2+7 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<pre><code class=\"language-text\">configure: Using default toolchain microsoft (Microsoft Visual Studio)\nconfigure: error: Cannot locate a valid Visual Studio installation\nconfigure exiting with result code 1\n</code></pre>\n<h2>OpenJDK 11 (11.0.26-3)</h2>\n<p>11はまだビルドが通ります。\nいつまで使う気なんでしょうね</p>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk-11.0.25+9 \\\n--with-jtreg=/cygdrive/c/java/jtreg\n</code></pre>\n<pre><code class=\"language-sh\">make all; make run-test-tier1\n</code></pre>\n<h2>OpenJDK 8 (jdk8u442-b04)</h2>\n<p><code>u442</code>ってもはや何なんだよって感じです</p>\n<pre><code class=\"language-sh\">bash configure \\\n--with-boot-jdk=/cygdrive/c/java/jdk8u432-b06 \\\n--with-jtreg=/cygdrive/c/java/jtreg \\\n--with-freetype-src=/cygdrive/c/src/freetype-2.5.3\n</code></pre>\n<p><code>bash configure</code>までは通るけど、ビルドはコケます。</p>\n<pre><code class=\"language-sh\">make all\n</code></pre>\n<p>おわり</p>",
      "date_published": "2024-12-20T00:00:00Z"
    },
    {
      "id": "https://www.jyuch.dev/posts/2024/09-14-docker-cache/",
      "url": "https://www.jyuch.dev/posts/2024/09-14-docker-cache/",
      "title": "Docker Buildxでもキャッシュしたい",
      "content_html": "<h1>はじめに</h1>\n<p>しばらくぶりにDockerに触ったらなんかいろいろとキャッシュ周りが変わっていたのでそれについてです。</p>\n<h1>Buildx</h1>\n<p>どうも最近のDockerはMoby BuildKitを<code>docker</code>コマンドから透過的に扱えるようになったようです。\nそして、BuildKitをDockerから使うための拡張がBuildxです。</p>\n<p>BuildKit君はいい感じにキャッシュを扱えるようなので、その辺を確認してみましょう。</p>\n<h1>パッケージマネージャ</h1>\n<h2>APT</h2>\n<p>昔は<code>apt-get</code>コマンドを鬼のように<code>&amp;&amp;</code>で連結して、最後に<code>rm -rf /var/lib/apt/lists/*</code>でキャッシュファイルを消し飛ばしてイメージをコンパクションするのがノウハウでした。</p>\n<p>そうすると、イメージサイズは小さくなりますが毎回パッケージをダウンロードしてくることになるので、ビルド時間が伸びるという欠点がありました。</p>\n<p>BuildKitは特定のディレクトリをキャッシュとしてマウントすることで、イメージの再ビルド時にそのディレクトリを復元することができます。</p>\n<pre><code class=\"language-Dockerfile\">FROM debian:bookworm\n\nRUN rm -f /etc/apt/apt.conf.d/docker-clean; \\\n    echo 'Binary::apt::APT::Keep-Downloaded-Packages &quot;true&quot;;' \\\n      &gt; /etc/apt/apt.conf.d/keep-cache\n\nRUN --mount=type=cache,target=/var/cache/apt,sharing=locked \\\n    --mount=type=cache,target=/var/lib/apt,sharing=locked \\\n    set -eux; \\\n    apt-get update; \\\n    apt-get install -y --no-install-recommends \\\n      sl;\n</code></pre>\n<p><code>apt-get</code>のタイミングでリポジトリキャッシュを<code>cache</code>タイプでマウントしています。\nこうすることで2回目以降は普通の<code>apt</code>のようにパッケージキャッシュを使ってくれるようです。</p>\n<p>ところで、初段のステージで<code>/etc/apt/apt.conf.d/docker-clean</code>を消し去ってますね。</p>\n<p>Dockerだとキャッシュが刺さってイメージが肥大化するから<code>apt</code>の最後にキャッシュを消し飛ばすようにしている設定ファイルのようです。</p>\n<p>じゃあ何すか</p>\n<p><code>rm -rf /var/lib/apt/lists/*</code>は無駄だったって事すか</p>\n<h2>DNF</h2>\n<p>DNF君も基本的には同じです。</p>\n<p>Amazon Linux 2023のベースイメージではダウンロードキャッシュをしないようにしていたので、ダウンロードキャッシュをする設定を挟んでから<code>dnf install</code>します。</p>\n<pre><code class=\"language-Dockerfile\">FROM amazonlinux:2023\n\nRUN echo &quot;keepcache=True&quot; &gt;&gt; /etc/dnf/dnf.conf\n\nRUN --mount=type=cache,target=/var/cache/dnf \\\n    --mount=type=cache,target=/var/lib/dnf \\\n    dnf install -y \\\n      gcc gcr lvm2 clang\n</code></pre>\n<h2>YUM</h2>\n<p>CentOS7がEoLを迎えてもう<code>yum</code>コマンドを打つ機会はない。そんなふうに考えていた時期が俺にもありました</p>\n<p>AWS Lambdaの（少なくともPythonの）ベースイメージがAmazon Linuxが2なんですよね。</p>\n<pre><code class=\"language-Dockerfile\">FROM amazonlinux:2\n\nRUN sed -i -e 's/keepcache=0/keepcache=1/' /etc/yum.conf\n\nRUN --mount=type=cache,target=/var/cache/yum \\\n    yum install -y \\\n      gcc gcr lvm2 clang\n</code></pre>\n<h1>ビルドシステム</h1>\n<h2>Rust</h2>\n<p>ビルド激重Rust君です。</p>\n<pre><code class=\"language-Dockerfile\">FROM rust:1.81.0-slim AS build\n\nWORKDIR /app\n\nRUN --mount=type=bind,source=src,target=src \\\n    --mount=type=bind,source=Cargo.toml,target=Cargo.toml \\\n    --mount=type=bind,source=Cargo.lock,target=Cargo.lock \\\n    --mount=type=cache,target=/app/target/ \\\n    --mount=type=cache,target=/usr/local/cargo/git/db \\\n    --mount=type=cache,target=/usr/local/cargo/registry \\\n    set -eux; \\\n    cargo build --locked --release; \\\n    cp ./target/release/hello_rust /bin/hello_rust\n\nFROM debian:stable-slim AS final\nCOPY --from=build /bin/hello_rust /bin/hello_rust\nENTRYPOINT [&quot;/bin/hello_rust&quot;]\n</code></pre>\n<p>ソース類は<code>bind</code>でマウントしてしまえばそもそもビルドステージへの転送すら不要なようです。</p>\n<p>あとはcargoのパッケージキャッシュとビルドキャッシュを<code>cache</code>でバインドすれば余計なパッケージの再取得やリビルドが走りません。</p>\n<p>あとはいつものように最終的なイメージをビルドしているステージに成果物を送り込めば完了です。</p>\n<h2>Python</h2>\n<p>最近触っているのでまぁ一応Pythonも確認してみましょう。</p>\n<pre><code class=\"language-Dockerfile\">FROM python:3.12-bookworm\n\nRUN --mount=type=bind,source=requirements.txt,target=requirements.txt \\\n    --mount=type=cache,target=/root/.cache/pip \\\n    pip install -r requirements.txt\n\nCOPY main.py .\n\nCMD [&quot;python&quot;, &quot;main.py&quot;]\n</code></pre>\n<p>Rustと同じようにパッケージマネージャのキャッシュをそのまま<code>cache</code>でマウントするだけです。</p>\n<p>おわり</p>",
      "date_published": "2024-09-14T00:00:00Z"
    }
  ]
}